#ifndef _STARS_H_
#define _STARS_H_

typedef void *(*block_kernel)(int nrows, int ncols, int *irow, int *icol,
        void *row_data, void *col_data, void *result);

typedef struct STARS_Array
{
    int ndim;
    // Number of dimensions of array.
    int *shape;
    // Shape of array.
    int *stride;
    // Size of step to increase value of corresponding axis by 1
    char order;
    // C or Fortran order. C-order means stride is descending, Fortran-order
    // means stride is ascending.
    int size;
    // Number of elements of an array.
    char dtype;
    // Data type of each element of array. Possile value is 's', 'd', 'c' or
    // 'z', much like in names of LAPACK routines.
    size_t nbytes;
    // Size of buffer in bytes.
    void *buffer;
    // Buffer, containing array. Stored in Fortran style.
} STARS_Array;

STARS_Array *STARS_Array_new(int ndim, int *shape, char dtype);
STARS_Array *STARS_Array_new_like(STARS_Array *array);
STARS_Array *STARS_Array_copy(STARS_Array *array);
void STARS_Array_free(STARS_Array *array);
void STARS_Array_info(STARS_Array *array);
void STARS_Array_init(STARS_Array *array, char *kind);
void STARS_Array_info(STARS_Array *array);
void STARS_Array_init_randn(STARS_Array *array);
void STARS_Array_init_rand(STARS_Array *array);
void STARS_Array_init_zeros(STARS_Array *array);
void STARS_Array_init_ones(STARS_Array *array);
void STARS_Array_tomatrix(STARS_Array *array, char kind);
void STARS_Array_trans(STARS_Array *array);

typedef struct STARS_Problem
// Structure, storing all the necessary data for reconstruction of a matrix,
// generated by given kernel. Matrix elements are not stored in memory, but
// computed on demand.
{
    int nrows, ncols;
    // Number of rows and columns of corresponding matrix.
    char symm;
    // 'S' if problem is symmetric, and 'N' otherwise.
    char dtype;
    // Possible values are 's', 'd', 'c' or 'z', just as in LAPACK routines
    // names.
    void *row_data, *col_data;
    // Pointers to data, corresponding to rows and columns.
    block_kernel kernel;
    // Pointer to a function, returning submatrix on intersection of
    // given rows and columns.
    char *type;
    // Type of problem, useful for debugging and printing additional info.
    // It is up to user to set it as desired.
} STARS_Problem;

STARS_Problem *STARS_Problem_init(int nrows, int ncols, char symm, char dtype,
        void *row_data, void*col_data, block_kernel kernel, char *type);
void STARS_Problem_info(STARS_Problem *problem);

typedef struct STARS_BLR
// Block-low rank format. Entire matrix is divided into blocks by a grid.
// Some of blocks are low-rank, some are not.
{
    STARS_Problem *problem;
    // Pointer to a problem.
    char symm;
    // 'S' if format and problem are symmetric, and 'N' otherwise.
    int nrows, ncols;
    // Number of rows and columns of corresponding matrix.
    int *row_order, *col_order;
    // Permutation of rows and columns, such that each block is based on rows
    // and columns, going one after another.
    int nbrows, nbcols;
    // Number of block rows and block columns.
    int *ibrow_start, *ibcol_start;
    // Start row/column of each block rows/block column.
    int *ibrow_size, *ibcol_size;
    // Number of rows/columns of each block row/block column.
} STARS_BLR;

typedef struct STARS_BLRmatrix
// Approximation in block low-rank format.
{
    STARS_Problem *problem;
    // Pointer to a problem.
    STARS_BLR *format;
    // Pointer to block low-rank format.
    int bcount;
    // Number of blocks
    int *bindex;
    // block row and block column index as a pair of integers (bi, bj)
    int *brank;
    // Rank of each block or -1 if block os not low-rank.
    double **U, **V;
    // Arrays of pointers to low-rank factors U and V of each block.
    double **A;
    // Array of pointers to data of full-rank blocks.
} STARS_BLRmatrix;

STARS_BLRmatrix *STARS_blr__compress_algebraic_svd(STARS_BLR *format,
        double tol);
void STARS_BLRmatrix_info(STARS_BLRmatrix *mat);
void STARS_BLRmatrix_free(STARS_BLRmatrix *mat);
void STARS_BLR_info(STARS_BLR *format);
void STARS_BLR_free(STARS_BLR *format);
#endif // _STARS_H_
