#ifndef _STARS_H_
#define _STARS_H_

typedef struct Array Array;
typedef struct STARS_Problem STARS_Problem;
typedef struct STARS_Cluster STARS_Cluster;
typedef struct STARS_BLRF STARS_BLRF;
typedef struct STARS_BLRM STARS_BLRM;
typedef int (*block_kernel)(int, int, int *, int *, void *, void *, void *);

typedef enum {STARS_Dense, STARS_LowRank, STARS_Unknown} STARS_BlockStatus;
// Enum type to show lowrankness of admissible blocks

typedef enum {STARS_BLRF_Tiled, STARS_BLRF_H, STARS_BLRF_HODLR}
    STARS_BLRF_Type;
// Enum type to show format type (tiled, hierarchical HOLDR or hierarchical H).

typedef enum {STARS_ClusterTiled, STARS_ClusterHierarchical}
    STARS_ClusterType;
// Enum type to show type of clusterization.

struct Array
// N-dimensional array
{
    int ndim;
    // Number of dimensions of array.
    int *shape;
    // Shape of array.
    int *stride;
    // Size of step to increase value of corresponding axis by 1
    char order;
    // C or Fortran order. C-order means stride is descending, Fortran-order
    // means stride is ascending.
    int size;
    // Number of elements of an array.
    char dtype;
    // Data type of each element of array. Possile value is 's', 'd', 'c' or
    // 'z', much like in names of LAPACK routines.
    size_t dtype_size;
    // Size in bytes of each element of a matrix
    size_t nbytes;
    // Size of buffer in bytes.
    void *buffer;
    // Buffer, containing array. Stored in Fortran style.
};

// Routines to work with N-dimensional arrays
Array *Array_from_buffer(int ndim, int *shape, char dtype, char order,
        void *buffer);
// Init array from given buffer. Check if all parameters are good and
// proceed.
Array *Array_new(int ndim, int *shape, char dtype, char order);
// Allocation of memory for array
Array *Array_new_like(Array *array);
// Initialize new array with exactly the same shape, dtype and so on, but
// with a different memory buffer
Array *Array_copy(Array *array, char order);
// Create copy of array with given data layout or keeping layout if order ==
// 'N'
void Array_free(Array *array);
// Free memory, consumed by array structure and buffer
void Array_info(Array *array);
// Print all the data from Array structure
void Array_print(Array *array);
// Print elements of array, different rows of array are printed on different
// rows of output
void Array_init(Array *array, char *kind);
// Init buffer in a special manner: randn, rand, ones or zeros
void Array_init_randn(Array *array);
// Init buffer of array with random numbers of normal (0,1) distribution
void Array_init_rand(Array *array);
// Init buffer with random numbers of uniform [0,1] distribution
void Array_init_zeros(Array *array);
// Set all elements to 0.0
void Array_init_ones(Array *array);
// Set all elements to 1.0
void Array_tomatrix(Array *array, char kind);
// Convert N-dimensional array to 2-dimensional array (matrix) by
// collapsing dimensions. This collapse can be assumed as attempt to look
// at array as at a matrix with long rows (kind == 'R') or long columns
// (kind == 'C'). If kind is 'R', dimensions from 1 to the last are
// collapsed into columns. If kind is 'C', dimensions from 0 to the last
// minus one are collapsed into rows. Example: array of shape (2,3,4,5)
// will be collapsed to array of shape (2,60) if kind is 'R' or to array of
// shape (24,5) if kind is 'C'.
void Array_trans(Array *array);
// Transposition of array. No real transposition is performed, only changes
// shape, stride and order.
Array *Array_dot(Array* A, Array *B);
// GEMM for two arrays. Multiplication is performed by last dimension of
// array A and first dimension of array B. These dimensions, data types and
// ordering of both arrays should be equal.
int Array_SVD(Array *array, Array **U, Array **S, Array **V);
// Compute short SVD of 2-dimensional array
int SVD_get_rank(Array *S, double tol, char type);
// Find rank by singular values and given accuracy tolerance
// (Frobenius or Spectral norm)
void Array_scale(Array *array, char kind, Array *factor);
// Apply row or column scaling to array
double Array_diff(Array *array, Array *array2);
// Measure Frobenius error of approximation of array by array2
double Array_norm(Array *array);
// Measure Frobenius norm of array
Array *Array_convert(Array *array, char dtype);
// Copy array and convert data type
int SVD_get_rank(Array *S, double tol, char type);
// Returns rank by given array of singular values, tolerance and type of norm
// ('2' for spectral norm, 'F' for Frobenius norm)
int Array_Cholesky(Array *array, char uplo);
// Cholesky factoriation for an array


struct STARS_Problem
// Structure, storing all the necessary data for reconstruction of matrix,
// generated by given kernel. This matrix may be not 2-dimensional (e.g. for
// Astrophysics problem, where each matrix entry is a vector of 3 elements.
// Matrix elements are not stored in memory, but computed on demand.
// Rows correspond to first dimension of the array and columns correspond to
// last dimension of the array.
{
    int ndim;
    // Real dimensionality of corresponding array. ndim=2 for problems with
    // scalar kernel. ndim=3 for Astrophysics problem. May be greater than 2.
    int *shape;
    // Real shape of corresponding array.
    char symm;
    // 'S' if problem is symmetric, and 'N' otherwise.
    char dtype;
    // Possible values are 's', 'd', 'c' or 'z', just as in LAPACK routines
    // names.
    size_t dtype_size;
    // Size of data type in bytes (size of scalar element of array).
    size_t entry_size;
    // Size of matrix entry in bytes (size of subarray, corresponding to
    // matrix entry on a given row on a given column). Equal to dtype_size,
    // multiplied by total number of elements and divided by number of rows
    // and by number of columns.
    void *row_data, *col_data;
    // Pointers to physical data, corresponding to rows and columns.
    block_kernel kernel;
    // Pointer to a function, returning submatrix on intersection of
    // given rows and columns. Rows stand for first dimension, columns stand
    // for last dimension.
    char *name;
    // Name of problem, useful for printing additional info. It is up to user
    // to set it as desired.
};

STARS_Problem *STARS_Problem_init(int ndim, int *shape, char symm, char dtype,
        void *row_data, void *col_data, block_kernel kernel, char *name);
// Init for STARS_Problem instance
// Parameters:
//   ndim: dimensionality of corresponding array. Equal 2+dimensionality of
//     kernel
//   shape: shape of corresponding array. shape[1:ndim-2] is equal to shape of
//     kernel
//   symm: 'S' for summetric problem, 'N' for nonsymmetric problem. Symmetric
//     problem require symmetric kernel and equality of row_data and col_data
//   dtype: data type of the problem. Equal to 's', 'd', 'c' or 'z' as in
//     LAPACK routines. Stands for data type of an element of a kernel.
//   row_data: pointer to some structure of physical data for rows
//   col_data: pointer to some srructure of physical data for columns
//   kernel: pointer to a function of interaction. More on this is written
//     somewhere else.
//   name: string, containgin name of the problem. Used only to print
//     information about structure problem.
// Returns:
//    STARS_Problem *: pointer to structure problem with proper filling of all
//    the fields of structure.
void STARS_Problem_free(STARS_Problem *problem);
// Free memory, consumed by data buffers of data
void STARS_Problem_info(STARS_Problem *problem);
// Print some info about Problem
Array *STARS_Problem_get_block(STARS_Problem *problem, int nrows, int ncols,
        int *irow, int *icol);
// Get submatrix on given rows and columns (rows=first dimension, columns=last
// dimension)
STARS_Problem *STARS_Problem_from_array(Array *array, char symm);
// Generate STARS_Problem with a given array and flag if it is symmetric
Array *STARS_Problem_to_array(STARS_Problem *problem);
// Compute matrix/array, corresponding to the problem


struct STARS_Cluster
// Information on clusterization (hierarchical or plain) of physical data.
{
    void *data;
    // Pointer to structure, holding physical data.
    int ndata;
    // Number of discrete elements, corresponding to physical data (particles,
    // grid nodes or mesh elements).
    int *pivot;
    // Pivoting for clusterization. After applying this pivoting, discrete
    // elements, corresponding to a given cluster, have indexes in a row.
    int nblocks;
    // Total number of subclusters/blocks of discrete elements.
    int *start;
    // Start point in array pivot of each block/subcluster of discrete
    // elements.
    int *size;
    // Size of each block/subcluster of discrete elements.
    STARS_ClusterType type;
    // Type of cluster (tiled or hierarchical).
};

STARS_Cluster *STARS_Cluster_init(void *data, int ndata, int *pivot,
        int nblocks, int *start, int *size, STARS_ClusterType type);
// Init for STARS_Cluster instance
// Parameters:
//   data: pointer structure, holding to physical data
//   ndata: number of discrete elements (particles or mesh elements),
//     corresponding to physical data
//   pivot: pivoting of clusterization. After applying this pivoting, rows (or
//     columns), corresponding to one block are placed in a row
//   nblocks: number of blocks/block rows/block columns/subclusters
//   start: start point of of indexes of discrete elements of each
//     block/subcluster in array pivot
//   size: size of each block/subcluster/block row/block column
void STARS_Cluster_free(STARS_Cluster *cluster);
// Free data buffers, consumed by clusterization information.
void STARS_Cluster_info(STARS_Cluster *cluster);
// Print some info about clusterization
STARS_Cluster *STARS_Cluster_init_tiled(void *data, int ndata, int block_size);
// Plain (non-hierarchical) division of data into blocks of discrete elements.


struct STARS_BLRF
// STARS Block Low-Rank Format, means non-nested division of a matrix/array
// into admissible blocks. Some of admissible blocks are low-rank, some are
// dense.
{
    STARS_Problem *problem;
    // Pointer to a problem.
    char symm;
    // 'S' if format and problem are symmetric, and 'N' otherwise.
    STARS_Cluster *row_cluster, *col_cluster;
    // Clusterization of rows and columns into blocks/subclusters of discrete
    // elements.
    int nbrows, nbcols;
    // Number of block rows/row subclusters and block columns/column
    // subclusters.
    int admissible_nblocks;
    // Number of admissible pairs of block rows and block columns.
    int *ibrow_admissible_start, *ibcol_admissible_start;
    int *ibrow_admissible_size, *ibcol_admissible_size;
    int *ibrow_admissible, *ibcol_admissible;
    STARS_BlockStatus *ibrow_admissible_status, *ibcol_admissible_status;
    // Store list of admissible blocks for each block row and block column as
    // sparse CSR format. admissible_start[i] and admissible_size[i] correspond
    // to start and size of list of admissible block columns/rows for block
    // row/column i, stored in array admissible. admissible_start and
    // admissible_size have nbrows/nbcols elements, admissible_block has
    // admissible_nblocks elements. admissible_status show status of each
    // admissible pair of block row and block column: guanrateed dense
    // (STARS_Dense), guaranteed low-rank (STARS_LowRank) or not known a priori
    // (STARS_Unknown).
    STARS_BLRF_Type type;
    // Type of format. Possible value is STARS_Tiled, STARS_H or STARS_HODLR.
};

STARS_BLRF *STARS_BLRF_init(STARS_Problem *problem, char symm,
        STARS_Cluster *row_cluster, STARS_Cluster *col_cluster,
        int admissible_nblocks, int *ibrow_admissible_start,
        int *ibcol_admissible_start, int *ibrow_admissible_size,
        int *ibcol_admissible_size, int *ibrow_admissible,
        int *ibcol_admissible, STARS_BlockStatus *ibrow_admissible_status,
        STARS_BlockStatus *ibcol_admissible_status, STARS_BLRF_Type type);
// Initialization of structure STARS_BLRF
// Parameters:
//   problem: pointer to a structure, holding all the information about problem
//   symm: 'S' if problem and division into blocks are both symmetric, 'N'
//     otherwise
//   row_cluster: clusterization of rows into block rows
//   col_cluster: clusterization of columns into block columns
//   admissible_nblocks: number of admissible blocks all in all
//   ibrow_admissible_start: starting point of list of admissible blocks
//     columns for a given block row in array ibrow_admissible
//   ibcol_admissible_start: starting point of list of admissible blocks
//     rows for a given block column in array ibcol_admissible
//   ibrow_admissible_size: number of admissible block columns for a given
//     block row
//   ibcol_admissible_size: number of admissible block rows for a given block
//     column
//   ibrow_admissible: array to store indexes of admissible block columns for
//     each block row.
//   ibcol_admissible: array to store indexes of admissible block rows for each
//     block column.
//   ibrow_admissible_status: status of each admissible pair of block row and
//     block column. STARS_Dense for guaranteed dense, STARS_LowRank for
//     guaranteed low-rank or STARS_Unknown if not known a priori.
//   ibcol_admissible_status: status of each admissible pair of block column
//     and block row. STARS_Dense for guaranteed dense, STARS_LowRank for
//     guaranteed low-rank or STARS_Unknown if not known a priori.
void STARS_BLRF_free(STARS_BLRF *blrf);
// Free memory, used by block low rank format (partitioning of array into
// blocks)
void STARS_BLRF_info(STARS_BLRF *blrf);
// Print short info on block partitioning
void STARS_BLRF_print(STARS_BLRF *blrf);
// Print full info on block partitioning
STARS_BLRF *STARS_BLRF_init_tiled(STARS_Problem *problem, STARS_Cluster
        *row_cluster, STARS_Cluster *col_cluster, char symm);
// Create plain division into tiles/blocks using plain cluster trees for rows
// and columns without actual pivoting

struct STARS_BLRM
// STARS Block Low-Rank Matrix, which is used as an approximation in non-nested
// block low-rank format.
{
    STARS_BLRF *blrf;
    // Pointer to block low-rank format.
    int nblocks;
    // Number of admissible blocks (that are required to be approximated).
    int *brank;
    // Rank of each block or -1 if block os not low-rank.
    Array **U, **V, **D;
    // Arrays of pointers to factors U and V of each low-rank block and dense
    // array of each dense block.
    void *U_alloc, *V_alloc, *D_alloc;
    // Pointer to memory buffer, holding buffers of low-rank factors of
    // low-rank blocks and dense buffers of dense blocks
    char alloc_type;
    // Type of memory allocation: '1' for allocating 3 big buffers U_alloc,
    // V_alloc and D_alloc, '2' for allocating many small buffers U, V and D.
};


STARS_BLRM *STARS_BLRM_init(STARS_BLRF *blrf, int nblocks, int *brank,
        Array **U, Array **V, Array **D, void *U_alloc, void *V_alloc,
        void *D_alloc, char alloc_type);
STARS_BLRM *STARS_blrf_tiled_compress_algebraic_svd(STARS_BLRF *blrf,
        int maxrank, double tol);
void STARS_BLRM_free(STARS_BLRM *blrm);
void STARS_BLRM_error(STARS_BLRM *blrm);
void STARS_BLRM_info(STARS_BLRM *blrm);
/*
STARS_BLRFmatrix *STARS_blrf_batched_algebraic_compress(STARS_BLRF *format,
        int maxrank, double tol);
void STARS_BLRFmatrix_info(STARS_BLRFmatrix *mat);
void STARS_BLRFmatrix_getblock(STARS_BLRFmatrix *mat, int i, int j, int order,
        int *shape, int *rank, void **U, void **V, void **A);
void STARS_BLRF_getblock(STARS_BLRF *format, int i, int j, int order, int *shape,
        void **A);
void STARS_BLRFmatrix_printKADIR(STARS_BLRFmatrix *mat);
void STARS_BLRFmatrix_heatmap(STARS_BLRFmatrix *mat, char *fname);
int batched_lowrank_approximation(STARS_BLRFmatrix *mat, int count, int *id,
        int maxrank, double tol, void **UV, int *rank);
int batched_get_block(STARS_BLRFmatrix *mat, int count, int *id, void **A);
*/
#endif // _STARS_H_
