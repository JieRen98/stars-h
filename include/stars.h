#ifndef _STARS_H_
#define _STARS_H_

typedef struct Array Array;
typedef struct STARS_Problem STARS_Problem;
typedef struct STARS_BLR STARS_BLR;
typedef struct STARS_BLRmatrix STARS_BLRmatrix;
typedef int (*block_kernel)(int, int, int *, int *, void *, void *, void *);

typedef enum {STARS_Dense, STARS_LowRank, STARS_Unknown} STARS_BlockStatus;
// Enum type to show lowrankness of admissible blocks

struct Array
// N-dimensional array
{
    int ndim;
    // Number of dimensions of array.
    int *shape;
    // Shape of array.
    int *stride;
    // Size of step to increase value of corresponding axis by 1
    char order;
    // C or Fortran order. C-order means stride is descending, Fortran-order
    // means stride is ascending.
    int size;
    // Number of elements of an array.
    char dtype;
    // Data type of each element of array. Possile value is 's', 'd', 'c' or
    // 'z', much like in names of LAPACK routines.
    size_t dtype_size;
    // Size in bytes of each element of a matrix
    size_t nbytes;
    // Size of buffer in bytes.
    void *buffer;
    // Buffer, containing array. Stored in Fortran style.
};

// Routines to work with N-dimensional arrays
Array *Array_from_buffer(int ndim, int *shape, char dtype, char order,
        void *buffer);
// Init array from given buffer. Check if all parameters are good and
// proceed.
Array *Array_new(int ndim, int *shape, char dtype, char order);
// Allocation of memory for array
Array *Array_new_like(Array *array);
// Initialize new array with exactly the same shape, dtype and so on, but
// with a different memory buffer
Array *Array_copy(Array *array, char order);
// Create copy of array with given data layout or keeping layout if order ==
// 'N'
void Array_free(Array *array);
// Free memory, consumed by array structure and buffer
void Array_info(Array *array);
// Print all the data from Array structure
void Array_print(Array *array);
// Print elements of array, different rows of array are printed on different
// rows of output
void Array_init(Array *array, char *kind);
// Init buffer in a special manner: randn, rand, ones or zeros
void Array_init_randn(Array *array);
// Init buffer of array with random numbers of normal (0,1) distribution
void Array_init_rand(Array *array);
// Init buffer with random numbers of uniform [0,1] distribution
void Array_init_zeros(Array *array);
// Set all elements to 0.0
void Array_init_ones(Array *array);
// Set all elements to 1.0
void Array_tomatrix(Array *array, char kind);
// Convert N-dimensional array to 2-dimensional array (matrix) by
// collapsing dimensions. This collapse can be assumed as attempt to look
// at array as at a matrix with long rows (kind == 'R') or long columns
// (kind == 'C'). If kind is 'R', dimensions from 1 to the last are
// collapsed into columns. If kind is 'C', dimensions from 0 to the last
// minus one are collapsed into rows. Example: array of shape (2,3,4,5)
// will be collapsed to array of shape (2,60) if kind is 'R' or to array of
// shape (24,5) if kind is 'C'.
void Array_trans(Array *array);
// Transposition of array. No real transposition is performed, only changes
// shape, stride and order.
Array *Array_dot(Array* A, Array *B);
// GEMM for two arrays. Multiplication is performed by last dimension of
// array A and first dimension of array B. These dimensions, data types and
// ordering of both arrays should be equal.
void Array_SVD(Array *array, Array **U, Array **S, Array **V);
// Compute short SVD of 2-dimensional array
int SVD_get_rank(Array *S, double tol, char type);
// Find rank by singular values and given accuracy tolerance
// (Frobenius or Spectral norm)
void Array_scale(Array *array, char kind, Array *factor);
// Apply row or column scaling to array
double Array_diff(Array *array, Array *array2);
// Measure Frobenius error of approximation of array by array2
double Array_norm(Array *array);
// Measure Frobenius norm of array
Array *Array_convert(Array *array, char dtype);
// Copy array and convert data type
int SVD_get_rank(Array *S, double tol, char type);
// Returns rank by given array of singular values, tolerance and type of norm
// ('2' for spectral norm, 'F' for Frobenius norm)

struct STARS_Problem
// Structure, storing all the necessary data for reconstruction of matrix,
// generated by given kernel. This matrix may be not 2-dimensional (e.g. for
// Astrophysics problem, where each matrix entry is a vector of 3 elements.
// Matrix elements are not stored in memory, but computed on demand.
// Rows correspond to first dimension of the array and columns correspond to
// last dimension of the array.
{
    int ndim;
    // Real dimensionality of corresponding array. ndim=2 for problems with
    // scalar kernel. ndim=3 for Astrophysics problem. May be greater than 2.
    int *shape;
    // Real shape of corresponding array.
    char symm;
    // 'S' if problem is symmetric, and 'N' otherwise.
    char dtype;
    // Possible values are 's', 'd', 'c' or 'z', just as in LAPACK routines
    // names.
    size_t dtype_size;
    // Size of data type in bytes (size of scalar element of array).
    size_t entry_size;
    // Size of matrix entry in bytes (size of subarray, corresponding to
    // matrix entry on a given row on a given column). Equal to dtype_size,
    // multiplied by total number of elements and divided by number of rows
    // and by number of columns.
    void *row_data, *col_data;
    // Pointers to physical data, corresponding to rows and columns.
    block_kernel kernel;
    // Pointer to a function, returning submatrix on intersection of
    // given rows and columns. Rows stand for first dimension, columns stand
    // for last dimension.
    char *name;
    // Name of problem, useful for printing additional info. It is up to user
    // to set it as desired.
};

STARS_Problem *STARS_Problem_init(int ndim, int *shape, char symm, char dtype,
        void *row_data, void *col_data, block_kernel kernel, char *name);
// Init for STARS_Problem instance
// Parameters:
//   ndim: dimensionality of corresponding array. Equal 2+dimensionality of
//     kernel
//   shape: shape of corresponding array. shape[1:ndim-2] is equal to shape of
//     kernel
//   symm: 'S' for summetric problem, 'N' for nonsymmetric problem. Symmetric
//     problem require symmetric kernel and equality of row_data and col_data
//   dtype: data type of the problem. Equal to 's', 'd', 'c' or 'z' as in
//     LAPACK routines. Stands for data type of an element of a kernel.
//   row_data: pointer to some structure of physical data for rows
//   col_data: pointer to some srructure of physical data for columns
//   kernel: pointer to a function of interaction. More on this is written
//     somewhere else.
//   name: string, containgin name of the problem. Used only to print
//     information about structure problem.
// Returns:
//    STARS_Problem *: pointer to structure problem with proper filling of all
//    the fields of structure.
void STARS_Problem_free(STARS_Problem *problem);
// Free memory, consumed by data buffers of data
void STARS_Problem_info(STARS_Problem *problem);
// Print some info about Problem
Array *STARS_Problem_get_block(STARS_Problem *problem, int nrows, int ncols,
        int *irow, int *icol);
// Get submatrix on given rows and columns (rows=first dimension, columns=last
// dimension)
STARS_Problem *STARS_Problem_from_array(Array *array, char symm);
// Generate STARS_Problem with a given array and flag if it is symmetric


struct STARS_BLR
// Block-low rank format. Entire matrix is divided into blocks by a grid.
// Some of blocks are low-rank, some are not.
{
    STARS_Problem *problem;
    // Pointer to a problem.
    char symm;
    // 'S' if format and problem are symmetric, and 'N' otherwise.
    int nrows, ncols;
    // Number of rows and columns of corresponding matrix.
    int *row_pivot, *col_pivot;
    // Permutation of rows and columns, such that each block is based on rows
    // and columns, going one after another.
    int nbrows, nbcols;
    // Number of block rows and block columns.
    int *ibrow_start, *ibcol_start;
    // Start row/column of each block rows/block column.
    int *ibrow_size, *ibcol_size;
    // Number of rows/columns of each block row/block column.
    int admissible_nblocks;
    // Number of admissible pairs of block rows and block columns.
    int *ibrow_admissible_start, *ibcol_admissible_start;
    int *ibrow_admissible_size, *ibcol_admissible_size;
    int *ibrow_admissible, *ibcol_admissible;
    STARS_BlockStatus *ibrow_admissible_status, *ibcol_admissible_status;
    // Store list of admissible blocks for each block row and block column as
    // sparse CSR format. admissible_start[i] and admissible_size[i] correspond
    // to start and size of list of admissible block columns/rows for block
    // row/column i, stored in array admissible. admissible_start and
    // admissible_size have nbrows/nbcols elements, admissible_block has
    // admissible_nblocks elements. admissible_status show status of each
    // admissible pair of block row and block column: guanrateed dense
    // (STARS_Dense), guaranteed low-rank (STARS_LowRank) or not known a priori
    // (STARS_Unknown).
};

STARS_BLR *STARS_BLR_init(STARS_Problem *problem, char symm, int *row_pivot,
        int *col_pivot, int nbrows, int nbcols, int *ibrow_start,
        int *ibcol_start, int *ibrow_size, int *ibcol_size,
        int admissible_nblocks, int *admissible_block_start,
        int *admissible_block_size, int *admissible_block,
        STARS_BlockStatus *admissible_block_status);
// Initialization of structure STARS_BLR
// Parameters:
//   problem: pointer to a structure, holding all the information about problem
//   symm: 'S' if problem and division into blocks are both symmetric, 'N'
//     otherwise
//   row_pivot: pivoting for rows, such that rows of each block are placed one
//     after another
//   col_pivot: pivoting for columns, such that columns of each block are
//     placed one after another
//   nbrows: number of block rows
//   nbcols: number of block columns
//   ibrow_start: array of start rows for each block row
//   ibcol_start: array of start column for each block column
//   ibrow_size: array of numbers of rows, presented in each block row
//   ibcol_size: array of numbers of columns, presented in each block column
//   admissible_nblocks: number of admissible blocks all in all
//   admissible_block_start: starting point of list of admissibly blocks for a
//     given block in array admissilbe_block
//   admissible_block_size: number of admissible blocks for a given block
//   admissible_block: array to store indexes of admissible blocks for each
//     block.
void STARS_BLR_free(STARS_BLR *blr);
// Free memory, used by block low rank format (partitioning of array into
// blocks)
void STARS_BLR_info(STARS_BLR *blr);
// Print short info on block partitioning
void STARS_BLR_print(STARS_BLR *blr);
// Print full info on block partitioning

struct STARS_BLRmatrix
//!! Should decide on name of this structure
// Approximation in block low-rank format.
{
    STARS_BLR *format;
    // Pointer to block low-rank format.
    int bcount;
    // Number of blocks
    int *bindex;
    // block row and block column index as a pair of integers (bi, bj)
    int *brank;
    // Rank of each block or -1 if block os not low-rank.
    Array **U, **V;
    // Arrays of pointers to low-rank factors U and V of each block.
    void *UV_alloc;
    // Pointer to memory buffer, holding buffers of all arrays U and V
    Array **A;
    // Array of pointers to data of full-rank blocks.
    void *A_alloc;
    // Pointer to memory buffer, holding buffers of all arrays A
};

STARS_BLRmatrix *STARS_blr__compress_algebraic_svd(STARS_BLR *format,
        int maxrank, double tol, int KADIR);
STARS_BLRmatrix *STARS_blr_batched_algebraic_compress(STARS_BLR *format,
        int maxrank, double tol);
void STARS_BLRmatrix_info(STARS_BLRmatrix *mat);
void STARS_BLRmatrix_free(STARS_BLRmatrix *mat);
void STARS_BLRmatrix_error(STARS_BLRmatrix *mat);
void STARS_BLRmatrix_getblock(STARS_BLRmatrix *mat, int i, int j, int order,
        int *shape, int *rank, void **U, void **V, void **A);
void STARS_BLR_getblock(STARS_BLR *format, int i, int j, int order, int *shape,
        void **A);
void STARS_BLRmatrix_printKADIR(STARS_BLRmatrix *mat);
void STARS_BLRmatrix_heatmap(STARS_BLRmatrix *mat, char *fname);
int batched_lowrank_approximation(STARS_BLRmatrix *mat, int count, int *id,
        int maxrank, double tol, void **UV, int *rank);
int batched_get_block(STARS_BLRmatrix *mat, int count, int *id, void **A);
#endif // _STARS_H_
